<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Immersive Viewer NEXT</title>

  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#c2c2c2}
    canvas{display:block}

    #modeButtons{
      position:fixed;
      top:14px; left:14px;
      z-index:20;
      display:flex;
      gap:8px;
    }
    .mBtn{
      width:200px;height:50px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(0,0,0,.55);
      color:#fff;
      font:700 16px/1 system-ui;
      cursor:pointer;
      backdrop-filter:blur(6px);
    }
    .mBtn.secondary{width:120px}
    .mBtn:hover{background:rgba(0,0,0,.7)}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>

<div id="app"></div>

<div id="modeButtons">
  <button id="btnBunkei" class="mBtn">文系</button>
  <button id="btnRikei"  class="mBtn">理系</button>
  <button id="btnCollect" class="mBtn secondary">回収</button>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';

const container = document.getElementById('app');

/* ================= 基本セット ================= */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#c2c2c2');

const camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 5000);
camera.position.set(0,40,80);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;

scene.add(new THREE.AmbientLight(0xffffff,1.0));
const sun = new THREE.DirectionalLight(0xffffff,1.2);
sun.position.set(100,200,100);
scene.add(sun);

/* ================= 効果音 ================= */
/*
  pin_fall.wav  : 落下開始（ヒュッ）
  pin_stick.wav : 刺さる（ポン）
  ※ 同じフォルダに置く
*/
const audioListener = new THREE.AudioListener();
camera.add(audioListener);

const fallSound = new THREE.Audio(audioListener);
const stickSound = new THREE.Audio(audioListener);
const audioLoader = new THREE.AudioLoader();

audioLoader.load('./pin_fall.wav', b=>{ fallSound.setBuffer(b); fallSound.setVolume(0.25); });
audioLoader.load('./pin_stick.wav',b=>{ stickSound.setBuffer(b); stickSound.setVolume(0.35); });

/* ================= ピン共通 ================= */
const allPins = [];
const DROP_FROM_Y = 80;
const DROP_MS = 850;
const COLLECT_MS = 650;
const DROP_INTERVAL = 500; // ★ 0.5秒間隔

const STRETCH_UP = 1.5;
const SQUASH_DOWN = 0.55;

function createPin({id,pos,href,icon,scale=3}){
  const tex = new THREE.TextureLoader().load(icon);
  const mat = new THREE.SpriteMaterial({map:tex,transparent:true});
  const pin = new THREE.Sprite(mat);
  pin.position.set(...pos);
  pin.scale.set(scale,scale,1);
  pin.userData = {
    id,
    href,
    baseScale: scale,
    _homePos: new THREE.Vector3(...pos),
    _raisedPos: new THREE.Vector3(pos[0], pos[1]+DROP_FROM_Y, pos[2]),
    _anim:null
  };
  pin.position.copy(pin.userData._raisedPos);
  pin.visible = false;
  scene.add(pin);
  allPins.push(pin);
  return pin;
}

/* ================= アニメ ================= */
function animatePinTo(pin,to,ms,kind){
  pin.userData._anim = {
    from: pin.position.clone(),
    to: to.clone(),
    t0: performance.now(),
    dur: ms,
    kind
  };
  pin.visible = true;
  if(kind==='drop' && fallSound.isBuffer){
    fallSound.stop();
    fallSound.play();
  }
}

function updatePinAnim(pin, now){
  const a = pin.userData._anim;
  if(!a) return;

  const t = Math.min(1,(now-a.t0)/a.dur);
  const k = 1-Math.pow(1-t,3);

  let y = THREE.MathUtils.lerp(a.from.y,a.to.y,k);
  let sx=1, sy=1;

  if(a.kind==='drop'){
    if(t>0.15&&t<0.65){
      const u=(t-0.15)/0.5;
      const s=THREE.MathUtils.lerp(1,STRETCH_UP,Math.sin(u*Math.PI));
      sy=s; sx=1/Math.sqrt(s);
    }
    if(t>0.78){
      const u=(t-0.78)/0.22;
      const sq=THREE.MathUtils.lerp(1,SQUASH_DOWN,Math.sin(u*Math.PI));
      sy*=sq; sx*=1/sq;
      const damp=Math.exp(-8*u);
      y+=(-1.2)*Math.sin(u*Math.PI*5)*damp;
      if(t>0.95 && stickSound.isBuffer && !stickSound.isPlaying){
        stickSound.play();
      }
    }
  }

  pin.position.y=y;
  const base=pin.userData.baseScale;
  pin.scale.set(base*sx,base*sy,1);

  if(t>=1){
    pin.userData._anim=null;
    if(a.kind==='collect'){
      pin.visible=false;
    }else{
      pin.position.copy(pin.userData._homePos);
      pin.scale.set(base,base,1);
    }
  }
}


  /* ================= ピン定義 ================= */
// ※ icon は既存の png を指定
const pins = {
  p1: createPin({id:'p1', pos:[-14, 3,-20], icon:'./pin1blue.png'}),
  p2: createPin({id:'p2', pos:[-37,15, 41], icon:'./pin1blue.png'}),
  p3: createPin({id:'p3', pos:[-37, 3, 20], icon:'./pin1blue.png'}),
  p4: createPin({id:'p4', pos:[  0,10, 22], icon:'./pin1blue.png'}),
  p5: createPin({id:'p5', pos:[-17, 3,  7], icon:'./pin1blue.png'}),
  p6: createPin({id:'p6', pos:[-30, 3,  5], icon:'./pin1blue.png'}),
  p7: createPin({id:'p7', pos:[-14, 6, 55], icon:'./pin1blue.png'}),
  p8: createPin({id:'p8', pos:[  0,12, 47], icon:'./pin1blue.png'}),
  p9: createPin({id:'p9', pos:[ 22,12, 47], icon:'./pin1blue.png'}),
  p10:createPin({id:'p10',pos:[  2, 3,-10], icon:'./pin1blue.png'}),
  p11:createPin({id:'p11',pos:[ -3, 6,-50], icon:'./pin1blue.png'}),
  p12:createPin({id:'p12',pos:[ 36, 9,-12], icon:'./pin1blue.png'}),
};

/* ================= 文系・理系割り当て ================= */
const BUNKEI = ['p1','p2','p3','p4','p9','p11','p12'];
const RIKEI  = ['p1','p5','p6','p7','p8','p9','p10','p12'];

/* ================= 順次落下ロジック ================= */
function dropSequential(ids){
  ids.forEach((id, i)=>{
    const pin = pins[id];
    if(!pin) return;
    setTimeout(()=>{
      animatePinTo(
        pin,
        pin.userData._homePos,
        DROP_MS,
        'drop'
      );
    }, i * DROP_INTERVAL);
  });

  // それ以外は回収
  Object.values(pins).forEach(p=>{
    if(!ids.includes(p.userData.id)){
      animatePinTo(
        p,
        p.userData._raisedPos,
        COLLECT_MS,
        'collect'
      );
    }
  });
}

function collectAll(){
  Object.values(pins).forEach(p=>{
    animatePinTo(
      p,
      p.userData._raisedPos,
      COLLECT_MS,
      'collect'
    );
  });
}

/* ================= ボタン ================= */
document.getElementById('btnBunkei').onclick = ()=>{
  dropSequential(BUNKEI);
};
document.getElementById('btnRikei').onclick = ()=>{
  dropSequential(RIKEI);
};
document.getElementById('btnCollect').onclick = ()=>{
  collectAll();
};

/* ================= レンダーループ ================= */
function animate(){
  const now = performance.now();
  allPins.forEach(p=>updatePinAnim(p, now));
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ================= リサイズ ================= */
window.addEventListener('resize', ()=>{
  camera.aspect = container.clientWidth/container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});
</script>
</body>
</html>
