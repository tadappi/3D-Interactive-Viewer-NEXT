<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20autorota — three.js viewer (sRGB + Shadow + GUI + Pins)</title>
  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#c2c2c2}
    canvas{display:block}

    /* ===== オーバーレイ小ウィンドウ ===== */
    #overlay{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(50vw);height:min(60vh);background:#111;border-radius:10px;
      box-shadow:0 10px 30px rgba(0,0,0,.6);overflow:hidden;display:none;z-index:10
    }
    #overlay.visible{display:block}
    #overlay-header{height:28px;display:flex;align-items:center;justify-content:space-between;padding:0 8px;background:rgba(20,20,20,.95);color:#eee;font:12px/1 system-ui;cursor:move}
    #overlay-title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:calc(100% - 40px)}
    #overlay-close{border:none;background:transparent;color:#ccc;cursor:pointer;font-size:14px}
    #overlay-close:hover{color:#fff}
    #overlay-iframe{width:100%;height:calc(100% - 28px);border:none;background:#000}

    /* 上端中央タイトル */
    #top-title{position:fixed;top:8px;left:50%;transform:translateX(-50%);z-index:4;pointer-events:none}
    #top-title img{display:block;max-width:90vw;height:auto}

    /* 左上ボタン */
    #modeButtons{position:fixed;top:14px;left:14px;z-index:20;display:flex;gap:8px}
    .mBtn{width:200px;height:50px;border-radius:10px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff;font:700 16px/1 system-ui;cursor:pointer}
    .mBtn.secondary{width:120px}
  </style>

  <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.165.0/build/three.module.js" } }</script>
</head>
<body>
  <div id="app"></div>
  <div id="top-title"><img src="./title.png"></div>

  <div id="modeButtons">
    <button id="btnBunkei" class="mBtn">文系</button>
    <button id="btnRikei"  class="mBtn">理系</button>
    <button id="btnCollect" class="mBtn secondary">回収</button>
  </div>

  <div id="overlay">
    <div id="overlay-header">
      <div id="overlay-title">Loading…</div>
      <button id="overlay-close">✕</button>
    </div>
    <iframe id="overlay-iframe" src="about:blank" allowfullscreen></iframe>
  </div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

// ========================= 基本 =========================
const container = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#c2c2c2');

const camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 5000);
camera.position.set(0,40,80);

const controls = new OrbitControls(camera, renderer.domElement);
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;
controls.target.set(0,0,0);

scene.add(new THREE.AmbientLight(0xffffff,1));

// ========================= テクスチャ =========================
const texCache = new Map();
function loadTex(url){ if(texCache.has(url)) return texCache.get(url); const t=new THREE.TextureLoader().load(url); texCache.set(url,t); return t; }

// ========================= 導線プレーン（XZ平面） =========================
function createRoutePlane({png, center=[0,0,0], size=[60,20], y=0.25}){
  const tex = loadTex(png);
  const geo = new THREE.PlaneGeometry(size[0], size[1]);
  const mat = new THREE.MeshBasicMaterial({ map:tex, transparent:true, depthWrite:false });
  const m = new THREE.Mesh(geo, mat);
  m.rotation.x = -Math.PI/2;
  m.position.set(center[0], y, center[2]);
  m.visible = false;
  return m;
}

// ========================= ピン =========================
const clickableObjects = [];
const allPins = [];
const pinById = new Map();

function createPin({id,pos,href,iconBlue,iconRed,labelPng}){
  const mat = new THREE.SpriteMaterial({ map: loadTex(iconBlue), transparent:true });
  const pin = new THREE.Sprite(mat);
  pin.position.set(...pos);
  pin.scale.set(3,3,1);
  pin.userData = { id, href, type:'pin', _deployed:false };
  return pin;
}

function registerPin(pin){ allPins.push(pin); pinById.set(pin.userData.id,pin); pin.visible=false; }

// ========================= モデル =========================
const routeByPinId = new Map();

new GLTFLoader().load('./100.glb',(gltf)=>{
  const root = gltf.scene;
  scene.add(root);

  // 共通ピン（例：生協）
  const pin = createPin({
    id:'p1_event', pos:[-14,3,-20], href:'./eventarea.mp4',
    iconBlue:'./pin1blue.png', iconRed:'./pin1red.png', labelPng:'./seikyo.png'
  });
  root.add(pin); clickableObjects.push(pin); registerPin(pin);

  // 導線PNG（生協 → イベント広場）
  const route = createRoutePlane({
    png:'./route_seikyo.png',
    center:[-5,0,-30],
    size:[70,25],
    y:0.3
  });
  root.add(route);
  routeByPinId.set('p1_event', route);

  // 表示テスト用：常時ピンを刺した状態
  pin.visible = true;
  pin.userData._deployed = true;
});

// ========================= Raycast & Hover =========================
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoverObject = null;

renderer.domElement.addEventListener('pointermove',e=>{
  const r = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX-r.left)/r.width)*2-1;
  mouse.y = -((e.clientY-r.top)/r.height)*2+1;
});

function tick(){
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(clickableObjects);
  let hit = hits.length ? hits[0].object : null;

  if(hoverObject !== hit){
    routeByPinId.forEach(r=>r.visible=false);
    hoverObject = hit;
    if(hoverObject){
      const id = hoverObject.userData.id;
      const route = routeByPinId.get(id);
      if(route && hoverObject.userData._deployed) route.visible = true;
    }
  }

  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}

tick();
</script>
</body>
</html>
